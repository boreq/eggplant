// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//+build !wireinject

package wire

import (
	auth2 "github.com/boreq/eggplant/adapters/auth"
	"github.com/boreq/eggplant/adapters/music/library"
	"github.com/boreq/eggplant/application"
	"github.com/boreq/eggplant/application/auth"
	"github.com/boreq/eggplant/application/music"
	"github.com/boreq/eggplant/application/queries"
	"github.com/boreq/eggplant/internal/config"
	"github.com/boreq/eggplant/internal/service"
	"github.com/boreq/eggplant/ports/http"
	"go.etcd.io/bbolt"
)

// Injectors from wire.go:

func BuildTransactableAuthRepositories(tx *bbolt.Tx) (*auth.TransactableRepositories, error) {
	invitationRepository, err := auth2.NewInvitationRepository(tx)
	if err != nil {
		return nil, err
	}
	userRepository, err := auth2.NewUserRepository(tx)
	if err != nil {
		return nil, err
	}
	transactableRepositories := &auth.TransactableRepositories{
		Invitations: invitationRepository,
		Users:       userRepository,
	}
	return transactableRepositories, nil
}

func BuildTransactableQueryRepositories(tx *bbolt.Tx) (*queries.TransactableRepositories, error) {
	userRepository, err := auth2.NewUserRepository(tx)
	if err != nil {
		return nil, err
	}
	transactableRepositories := &queries.TransactableRepositories{
		Users: userRepository,
	}
	return transactableRepositories, nil
}

func BuildAuthForTest(db *bbolt.DB) (*auth.Auth, error) {
	bcryptPasswordHasher := auth2.NewBcryptPasswordHasher()
	wireAuthRepositoriesProvider := newAuthRepositoriesProvider()
	authTransactionProvider := auth2.NewAuthTransactionProvider(db, wireAuthRepositoriesProvider)
	registerInitialHandler := auth.NewRegisterInitialHandler(bcryptPasswordHasher, authTransactionProvider)
	registerHandler := auth.NewRegisterHandler(bcryptPasswordHasher, authTransactionProvider)
	cryptoAccessTokenGenerator := auth2.NewCryptoAccessTokenGenerator()
	loginHandler := auth.NewLoginHandler(bcryptPasswordHasher, authTransactionProvider, cryptoAccessTokenGenerator)
	logoutHandler := auth.NewLogoutHandler(authTransactionProvider, cryptoAccessTokenGenerator)
	checkAccessTokenHandler := auth.NewCheckAccessTokenHandler(authTransactionProvider, cryptoAccessTokenGenerator)
	listHandler := auth.NewListHandler(authTransactionProvider)
	cryptoStringGenerator := auth2.NewCryptoStringGenerator()
	createInvitationHandler := auth.NewCreateInvitationHandler(cryptoStringGenerator, authTransactionProvider)
	removeHandler := auth.NewRemoveHandler(authTransactionProvider)
	setPasswordHandler := auth.NewSetPasswordHandler(bcryptPasswordHasher, authTransactionProvider)
	authAuth := &auth.Auth{
		RegisterInitial:  registerInitialHandler,
		Register:         registerHandler,
		Login:            loginHandler,
		Logout:           logoutHandler,
		CheckAccessToken: checkAccessTokenHandler,
		List:             listHandler,
		CreateInvitation: createInvitationHandler,
		Remove:           removeHandler,
		SetPassword:      setPasswordHandler,
	}
	return authAuth, nil
}

func BuildAuth(conf *config.Config) (*auth.Auth, error) {
	bcryptPasswordHasher := auth2.NewBcryptPasswordHasher()
	db, err := newBolt(conf)
	if err != nil {
		return nil, err
	}
	wireAuthRepositoriesProvider := newAuthRepositoriesProvider()
	authTransactionProvider := auth2.NewAuthTransactionProvider(db, wireAuthRepositoriesProvider)
	registerInitialHandler := auth.NewRegisterInitialHandler(bcryptPasswordHasher, authTransactionProvider)
	registerHandler := auth.NewRegisterHandler(bcryptPasswordHasher, authTransactionProvider)
	cryptoAccessTokenGenerator := auth2.NewCryptoAccessTokenGenerator()
	loginHandler := auth.NewLoginHandler(bcryptPasswordHasher, authTransactionProvider, cryptoAccessTokenGenerator)
	logoutHandler := auth.NewLogoutHandler(authTransactionProvider, cryptoAccessTokenGenerator)
	checkAccessTokenHandler := auth.NewCheckAccessTokenHandler(authTransactionProvider, cryptoAccessTokenGenerator)
	listHandler := auth.NewListHandler(authTransactionProvider)
	cryptoStringGenerator := auth2.NewCryptoStringGenerator()
	createInvitationHandler := auth.NewCreateInvitationHandler(cryptoStringGenerator, authTransactionProvider)
	removeHandler := auth.NewRemoveHandler(authTransactionProvider)
	setPasswordHandler := auth.NewSetPasswordHandler(bcryptPasswordHasher, authTransactionProvider)
	authAuth := &auth.Auth{
		RegisterInitial:  registerInitialHandler,
		Register:         registerHandler,
		Login:            loginHandler,
		Logout:           logoutHandler,
		CheckAccessToken: checkAccessTokenHandler,
		List:             listHandler,
		CreateInvitation: createInvitationHandler,
		Remove:           removeHandler,
		SetPassword:      setPasswordHandler,
	}
	return authAuth, nil
}

func BuildService(conf *config.Config) (*service.Service, error) {
	bcryptPasswordHasher := auth2.NewBcryptPasswordHasher()
	db, err := newBolt(conf)
	if err != nil {
		return nil, err
	}
	wireAuthRepositoriesProvider := newAuthRepositoriesProvider()
	authTransactionProvider := auth2.NewAuthTransactionProvider(db, wireAuthRepositoriesProvider)
	registerInitialHandler := auth.NewRegisterInitialHandler(bcryptPasswordHasher, authTransactionProvider)
	registerHandler := auth.NewRegisterHandler(bcryptPasswordHasher, authTransactionProvider)
	cryptoAccessTokenGenerator := auth2.NewCryptoAccessTokenGenerator()
	loginHandler := auth.NewLoginHandler(bcryptPasswordHasher, authTransactionProvider, cryptoAccessTokenGenerator)
	logoutHandler := auth.NewLogoutHandler(authTransactionProvider, cryptoAccessTokenGenerator)
	checkAccessTokenHandler := auth.NewCheckAccessTokenHandler(authTransactionProvider, cryptoAccessTokenGenerator)
	listHandler := auth.NewListHandler(authTransactionProvider)
	cryptoStringGenerator := auth2.NewCryptoStringGenerator()
	createInvitationHandler := auth.NewCreateInvitationHandler(cryptoStringGenerator, authTransactionProvider)
	removeHandler := auth.NewRemoveHandler(authTransactionProvider)
	setPasswordHandler := auth.NewSetPasswordHandler(bcryptPasswordHasher, authTransactionProvider)
	authAuth := auth.Auth{
		RegisterInitial:  registerInitialHandler,
		Register:         registerHandler,
		Login:            loginHandler,
		Logout:           logoutHandler,
		CheckAccessToken: checkAccessTokenHandler,
		List:             listHandler,
		CreateInvitation: createInvitationHandler,
		Remove:           removeHandler,
		SetPassword:      setPasswordHandler,
	}
	store, err := newThumbnailStore(conf)
	if err != nil {
		return nil, err
	}
	thumbnailHandler := music.NewThumbnailHandler(store)
	trackStore, err := newTrackStore(conf)
	if err != nil {
		return nil, err
	}
	trackHandler := music.NewTrackHandler(trackStore)
	delimiterAccessLoader := library.NewDelimiterAccessLoader()
	idGenerator := library.NewIdGenerator()
	libraryLibrary, err := newLibrary(delimiterAccessLoader, trackStore, store, idGenerator, conf)
	if err != nil {
		return nil, err
	}
	browseHandler := music.NewBrowseHandler(libraryLibrary)
	applicationMusic := application.Music{
		Thumbnail: thumbnailHandler,
		Track:     trackHandler,
		Browse:    browseHandler,
	}
	wireQueryRepositoriesProvider := newQueryRepositoriesProvider()
	queryTransactionProvider := auth2.NewQueryTransactionProvider(db, wireQueryRepositoriesProvider)
	statsHandler := queries.NewStatsHandler(trackStore, store, queryTransactionProvider)
	applicationQueries := application.Queries{
		Stats: statsHandler,
	}
	applicationApplication := &application.Application{
		Auth:    authAuth,
		Music:   applicationMusic,
		Queries: applicationQueries,
	}
	httpAuthProvider := http.NewHttpAuthProvider(applicationApplication)
	handler, err := http.NewHandler(applicationApplication, httpAuthProvider)
	if err != nil {
		return nil, err
	}
	server := http.NewServer(handler)
	serviceService := service.NewService(server)
	return serviceService, nil
}
